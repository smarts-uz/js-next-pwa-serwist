<!-- Generated by SpecStory -->

# Fixing Background Sync Example (2025-04-27 00:06:19)

_**User**_

@custom-sw.js  @sw.ts  Fix the background sync example make it proper

---

_**Assistant**_



---

Let me fix the background sync implementation to make it work properly across all files.

---

```diff
  import { Card } from "@/components/ui/card";
  import { Badge } from "@/components/ui/badge";
- import { CheckCircle2, XCircle, Clock, Upload } from "lucide-react";
+ import { CheckCircle2, XCircle, Clock, Upload, RefreshCw } from "lucide-react";
  
  interface UploadFile {
```

```diff
    timestamp: Date;
  }
+ 
+ // IndexedDB setup for storing offline uploads
+ const DB_NAME = "offlineUploadsDB";
+ const STORE_NAME = "pendingUploads";
+ 
+ const openDatabase = (): Promise<IDBDatabase> => {
+   return new Promise((resolve, reject) => {
+     const request = indexedDB.open(DB_NAME, 1);
+     
+     request.onerror = () => reject(request.error);
+     request.onsuccess = () => resolve(request.result);
+     
+     request.onupgradeneeded = (event) => {
+       const db = request.result;
+       if (!db.objectStoreNames.contains(STORE_NAME)) {
+         db.createObjectStore(STORE_NAME, { keyPath: "id" });
+       }
+     };
+   });
+ };
+ 
+ const saveToIndexedDB = async (fileData: any): Promise<void> => {
+   const db = await openDatabase();
+   return new Promise((resolve, reject) => {
+     const transaction = db.transaction(STORE_NAME, "readwrite");
+     const store = transaction.objectStore(STORE_NAME);
+     const request = store.put(fileData);
+     
+     request.onsuccess = () => resolve();
+     request.onerror = () => reject(request.error);
+   });
+ };
+ 
+ const getPendingUploads = async (): Promise<any[]> => {
+   const db = await openDatabase();
+   return new Promise((resolve, reject) => {
+     const transaction = db.transaction(STORE_NAME, "readonly");
+     const store = transaction.objectStore(STORE_NAME);
+     const request = store.getAll();
+     
+     request.onsuccess = () => resolve(request.result);
+     request.onerror = () => reject(request.error);
+   });
+ };
+ 
+ const removeFromIndexedDB = async (id: string): Promise<void> => {
+   const db = await openDatabase();
+   return new Promise((resolve, reject) => {
+     const transaction = db.transaction(STORE_NAME, "readwrite");
+     const store = transaction.objectStore(STORE_NAME);
+     const request = store.delete(id);
+     
+     request.onsuccess = () => resolve();
+     request.onerror = () => reject(request.error);
+   });
+ };
  
  export function BackgroundSyncExample() {
```

```diff
      "idle" | "uploading" | "completed"
    >("idle");
+ 
+   const loadPendingUploads = async () => {
+     try {
+       const pendingUploads = await getPendingUploads();
+       if (pendingUploads.length > 0) {
+         setFiles(prev => {
+           // Merge with existing files, avoiding duplicates
+           const existingIds = new Set(prev.map(f => f.id));
+           const newFiles = pendingUploads.filter(f => !existingIds.has(f.id));
+           return [...prev, ...newFiles];
+         });
+       }
+     } catch (error) {
+       console.error("Failed to load pending uploads:", error);
+     }
+   };
  
    useEffect(() => {
      setIsOnline(navigator.onLine);
-     const handleOnline = () => setIsOnline(true);
+     const handleOnline = () => {
+       setIsOnline(true);
+       // Trigger a background sync when back online
+       if ('serviceWorker' in navigator && 'SyncManager' in window) {
+         navigator.serviceWorker.ready.then(registration => {
+           registration.sync.register('myQueueName').catch(err => {
+             console.error('Background sync registration failed:', err);
+           });
+         });
+       }
+     };
+     
      const handleOffline = () => setIsOnline(false);
  
      window.addEventListener("online", handleOnline);
      window.addEventListener("offline", handleOffline);
  
-     // Listen for upload completion messages
+     // Listen for upload completion messages from the service worker
      const handleMessage = (event: MessageEvent) => {
-       if (event.data?.type === "UPLOAD_COMPLETE") {
+       if (event.data?.type === "UPLOAD_COMPLETE" && event.data?.fileId) {
          setFiles((prev) =>
            prev.map((file) =>
```

```diff
            )
          );
-       }
-     };
- 
-     window.addEventListener("message", handleMessage);
+         // Remove the completed upload from IndexedDB
+         removeFromIndexedDB(event.data.fileId).catch(console.error);
+       } else if (event.data?.type === "SYNC_COMPLETE") {
+         setUploadStatus("completed");
+         // Refresh the file list to update statuses
+         loadPendingUploads();
+       }
+     };
+ 
+     navigator.serviceWorker.addEventListener("message", handleMessage);
+     
+     // Load any pending uploads from IndexedDB
+     loadPendingUploads();
  
      return () => {
        window.removeEventListener("online", handleOnline);
        window.removeEventListener("offline", handleOffline);
-       window.removeEventListener("message", handleMessage);
+       navigator.serviceWorker.removeEventListener("message", handleMessage);
      };
    }, []);
```

```diff
      if (!selectedFiles) return;
  
+     setUploadStatus("uploading");
      const filesArray = Array.from(selectedFiles);
+     
      for (const file of filesArray) {
        const newFile: UploadFile = {
```

```diff
  
        setFiles((prev) => [...prev, newFile]);
+ 
+       // If offline, store the file data for later upload
+       if (!navigator.onLine) {
+         try {
+           // Convert file to ArrayBuffer to store in IndexedDB
+           const arrayBuffer = await file.arrayBuffer();
+           await saveToIndexedDB({
+             ...newFile,
+             file: arrayBuffer,
+             type: file.type,
+           });
+           continue; // Skip the fetch attempt when offline
+         } catch (error) {
+           console.error("Failed to save file for offline upload:", error);
+           setFiles((prev) =>
+             prev.map((f) =>
+               f.id === newFile.id ? { ...f, status: "failed" } : f
+             )
+           );
+           continue;
+         }
+       }
  
        const formData = new FormData();
```

```diff
              )
            );
+           
+           // Store in IndexedDB for persistence
+           const arrayBuffer = await file.arrayBuffer();
+           await saveToIndexedDB({
+             ...newFile,
+             file: arrayBuffer,
+             type: file.type,
+           });
          } else {
            // File was uploaded immediately
```

```diff
          }
        } catch (error) {
+         console.error("Upload error:", error);
          setFiles((prev) =>
            prev.map((f) =>
              f.id === newFile.id ? { ...f, status: "failed" } : f
            )
          );
+         
+         // If there was an error and we're online, it might be a server issue
+         // Still store it for retry with background sync
+         if (navigator.onLine) {
+           try {
+             const arrayBuffer = await file.arrayBuffer();
+             await saveToIndexedDB({
+               ...newFile,
+               file: arrayBuffer,
+               type: file.type,
+             });
+           } catch (dbError) {
+             console.error("Failed to save failed upload:", dbError);
+           }
+         }
+       }
+     }
+     
+     setUploadStatus("completed");
+   };
+ 
+   const handleSyncNow = async () => {
+     if ('serviceWorker' in navigator && 'SyncManager' in window) {
+       try {
+         await navigator.serviceWorker.ready;
+         await navigator.serviceWorker.sync.register('myQueueName');
+       } catch (err) {
+         console.error('Manual sync registration failed:', err);
        }
      }
```

```diff
              </Button>
            </label>
+           {!isOnline && files.some(file => file.status === "pending") && (
+             <Button variant="outline" onClick={handleSyncNow}>
+               <RefreshCw className="mr-2 h-4 w-4" />
+               Sync When Online
+             </Button>
+           )}
          </div>
          <Badge variant={isOnline ? "default" : "destructive"}>
```

---

Let me fix the linter error and update the service worker files to complete the background sync implementation.

---

```diff
      if ('serviceWorker' in navigator && 'SyncManager' in window) {
        try {
-         await navigator.serviceWorker.ready;
-         await navigator.serviceWorker.sync.register('myQueueName');
+         const registration = await navigator.serviceWorker.ready;
+         await registration.sync.register('myQueueName');
        } catch (err) {
          console.error('Manual sync registration failed:', err);
```

---

Now let's update the custom-sw.js file to properly handle the background sync:

---

```diff
    event.ports[0].postMessage(true);
  });
+ 
+ // IndexedDB setup for retrieving pending uploads
+ const DB_NAME = "offlineUploadsDB";
+ const STORE_NAME = "pendingUploads";
+ 
+ const openDatabase = () => {
+   return new Promise((resolve, reject) => {
+     const request = indexedDB.open(DB_NAME, 1);
+     
+     request.onerror = () => reject(request.error);
+     request.onsuccess = () => resolve(request.result);
+     
+     request.onupgradeneeded = (event) => {
+       const db = request.result;
+       if (!db.objectStoreNames.contains(STORE_NAME)) {
+         db.createObjectStore(STORE_NAME, { keyPath: "id" });
+       }
+     };
+   });
+ };
+ 
+ const getPendingUploads = async () => {
+   const db = await openDatabase();
+   return new Promise((resolve, reject) => {
+     const transaction = db.transaction(STORE_NAME, "readonly");
+     const store = transaction.objectStore(STORE_NAME);
+     const request = store.getAll();
+     
+     request.onsuccess = () => resolve(request.result);
+     request.onerror = () => reject(request.error);
+   });
+ };
+ 
+ const removePendingUpload = async (id) => {
+   const db = await openDatabase();
+   return new Promise((resolve, reject) => {
+     const transaction = db.transaction(STORE_NAME, "readwrite");
+     const store = transaction.objectStore(STORE_NAME);
+     const request = store.delete(id);
+     
+     request.onsuccess = () => resolve();
+     request.onerror = () => reject(request.error);
+   });
+ };
  
  // Handle background sync
```

```diff
      console.log("Background sync triggered:", event.tag);
      
-     // Get the queued requests from IndexedDB
-     // In a real implementation, you would access the queue data
-     try {
-       // Process the sync requests
+     try {
+       // Get the queued files from IndexedDB
+       const pendingUploads = await getPendingUploads();
+       console.log(`Found ${pendingUploads.length} pending uploads`);
+       
+       // Process each pending upload
+       for (const upload of pendingUploads) {
+         try {
+           // Create a new Blob from the stored ArrayBuffer
+           const fileBlob = new Blob([upload.file], { type: upload.type });
+           
+           // Create and send FormData with the file
+           const formData = new FormData();
+           formData.append("file", fileBlob, upload.name);
+           formData.append("fileId", upload.id);
+           formData.append("fileName", upload.name);
+           
+           // Attempt to upload the file
+           const response = await fetch("/api/upload", {
+             method: "POST",
+             body: formData
+           });
+           
+           if (!response.ok) {
+             throw new Error(`Upload failed with status: ${response.status}`);
+           }
+           
+           // If successful, remove from IndexedDB and notify clients
+           await removePendingUpload(upload.id);
+           
+           // Notify all clients about this specific upload completion
+           const clients = await self.clients.matchAll();
+           clients.forEach(client => {
+             client.postMessage({
+               type: "UPLOAD_COMPLETE",
+               fileId: upload.id,
+               message: "File upload completed successfully"
+             });
+           });
+           
+           console.log(`Successfully synced file: ${upload.name}`);
+         } catch (uploadError) {
+           console.error(`Error syncing file ${upload.name}:`, uploadError);
+           // We don't remove the file from IndexedDB so it can be retried later
+         }
+       }
+       
+       // Notify all clients that sync process is complete
        const clients = await self.clients.matchAll();
- 
-       // Notify clients about sync completion
-       clients.forEach((client) => {
+       clients.forEach(client => {
          client.postMessage({
            type: "SYNC_COMPLETE",
-           message: "Background sync completed successfully"
+           message: "Background sync completed"
          });
        });
        
-       console.log("Background sync completed successfully");
+       console.log("Background sync completed");
      } catch (error) {
        console.error("Error during background sync:", error);
-       // Sync will automatically retry based on the maxRetentionTime
+       // The sync will be retried automatically based on the maxRetentionTime
      }
    }
```

---

Now let's update the main service worker configuration file:

---

```diff
  import { defaultCache } from "@serwist/next/worker";
  import type { PrecacheEntry, SerwistGlobalConfig } from "serwist";
- import { Serwist, BackgroundSyncPlugin, NetworkFirst } from "serwist";
+ import { Serwist, BackgroundSyncPlugin, NetworkFirst, NetworkOnly } from "serwist";
  
  declare global {
```

```diff
  declare const self: ServiceWorkerGlobalScope;
  
+ // Create a background sync plugin with a reasonable retention time
  const backgroundSync = new BackgroundSyncPlugin("myQueueName", {
    maxRetentionTime: 24 * 60, // Retry for a maximum of 24 Hours (specified in minutes)
+   onSync: async ({ queue }) => {
+     // This function is called when the sync event fires
+     // The actual sync implementation is in custom-sw.js
+     // We're triggering a custom sync event for our own handling
+     self.dispatchEvent(new SyncEvent('myQueueName', { 
+       tag: 'myQueueName'
+     }));
+     
+     // We don't need to wait for the queue.replayRequests() since
+     // we handle the uploads manually in custom-sw.js
+     return true;
+   }
  });
  
```

```diff
    runtimeCaching: [
      ...defaultCache,
+     {
+       // Route for API requests with background sync for offline support
+       matcher: ({ request }) => request.url.includes('/api/upload'),
+       handler: new NetworkOnly({ 
+         plugins: [backgroundSync] 
+       }),
+     },
      {
        matcher: ({ request }) => request.destination === "document",
-       handler: new NetworkFirst({ plugins: [backgroundSync] }),
+       handler: new NetworkFirst(),
      },
    ],
```

---

Let's fix the linter errors in the service worker configuration:

---

```diff
  const backgroundSync = new BackgroundSyncPlugin("myQueueName", {
    maxRetentionTime: 24 * 60, // Retry for a maximum of 24 Hours (specified in minutes)
-   onSync: async ({ queue }) => {
+   onSync: async () => {
      // This function is called when the sync event fires
      // The actual sync implementation is in custom-sw.js
-     // We're triggering a custom sync event for our own handling
-     self.dispatchEvent(new SyncEvent('myQueueName', { 
-       tag: 'myQueueName'
-     }));
-     
-     // We don't need to wait for the queue.replayRequests() since
-     // we handle the uploads manually in custom-sw.js
-     return true;
+     try {
+       // Trigger the sync handler in custom-sw.js
+       const syncEvent = new Event('sync') as any;
+       syncEvent.tag = 'myQueueName';
+       self.dispatchEvent(syncEvent);
+     } catch (error) {
+       console.error('Error triggering custom sync handler:', error);
+     }
    }
  });
```

---

Now we need to create an example API route to handle the file uploads. Let's create that file:

---

```diff
- import { NextResponse } from "next/server";
+ import { NextRequest, NextResponse } from 'next/server';
  
- export async function POST(request: Request) {
+ export async function POST(request: NextRequest) {
    try {
+     // Simulate network conditions - could be controlled via env var for testing
+     // const shouldSimulateOffline = false;
+     // if (shouldSimulateOffline) {
+     //   // Simulate a network failure for testing background sync
+     //   return NextResponse.json({ error: 'Network error' }, { status: 500 });
+     // }
+ 
+     // Get the form data
      const formData = await request.formData();
-     const file = formData.get("file") as File;
-     const fileId = formData.get("fileId") as string;
-     const fileName = formData.get("fileName") as string;
+     const file = formData.get('file') as File;
+     const fileId = formData.get('fileId') as string;
+     const fileName = formData.get('fileName') as string;
  
-     if (!file) {
+     if (!file || !fileId) {
        return NextResponse.json(
-         { success: false, error: "No file provided" },
-         { status: 400 },
+         { error: 'Missing required file or file ID' },
+         { status: 400 }
        );
      }
  
-     console.log("File received:", {
-       id: fileId,
-       name: fileName,
-       size: file.size,
-       type: file.type,
-     });
- 
-     await new Promise((resolve) => setTimeout(resolve, 1000));
+     // Log file details
+     console.log(`Processing upload for file: ${fileName}, ID: ${fileId}, Size: ${file.size} bytes`);
+ 
+     // Simulate file processing delay
+     await new Promise(resolve => setTimeout(resolve, 1000));
  
+     // In a real app, you would save the file to your storage service
+     // For example: await uploadToS3(file, fileName);
+ 
+     // Return success response
      return NextResponse.json({
        success: true,
-       file: {
-         id: fileId,
-         name: fileName,
-         size: file.size,
-         type: file.type,
-       },
+       message: 'File uploaded successfully',
+       fileId,
+       fileName,
+       size: file.size,
      });
-   } catch (error: any) {
+   } catch (error) {
+     console.error('Error processing upload:', error);
      return NextResponse.json(
-       { success: false, error: error.message },
-       { status: 500 },
+       { error: 'Failed to process upload' },
+       { status: 500 }
      );
    }
```

---

The background sync implementation is now complete with a properly configured set of files. Let me explain what each component does:

1. **BackgroundSyncExample.tsx:**
   - Enhanced to store files in IndexedDB when offline
   - Adds support for retrying uploads with background sync when back online
   - Provides visual feedback on upload status
   - Adds a manual sync button for when back online

2. **custom-sw.js:**
   - Implements the actual background sync logic
   - Retrieves pending uploads from IndexedDB
   - Processes each upload and sends to the server
   - Notifies the UI of completed uploads

3. **sw.ts:**
   - Configures the service worker with proper routes
   - Sets up the background sync plugin
   - Ensures sync events are properly dispatched

4. **api/upload/route.ts:**
   - Handles file uploads on the server side
   - Includes commented code to simulate network failures for testing

This implementation ensures that users can select files for upload while offline, and the service worker will automatically upload them when the connection is restored. The UI provides clear feedback about which files are pending, failed, or completed.

To test this functionality, you can:
1. Load the app while online
2. Disconnect from the internet
3. Select files to upload (they will be stored in IndexedDB)
4. Reconnect to the internet
5. The service worker should automatically sync the files

---

