<!-- Generated by SpecStory -->

# Verifying Cache Deletion Success (2025-04-27 19:10:59)

_**User**_

How to check if the cache is deleted successfully?

---

_**Assistant**_



---

To check if a cache is deleted successfully in your service worker, you can add a few helper functions. Here's how:

---

```diff
  
  serwist.addEventListeners();
+ 
+ // Cache verification helpers
+ const checkCacheExists = async (cacheName: string): Promise<boolean> => {
+   const cacheNames = await caches.keys();
+   return cacheNames.includes(cacheName);
+ };
+ 
+ const deleteCache = async (cacheName: string): Promise<boolean> => {
+   try {
+     const cacheExistedBeforeDeletion = await checkCacheExists(cacheName);
+     if (!cacheExistedBeforeDeletion) {
+       console.log(`Cache "${cacheName}" doesn't exist, nothing to delete`);
+       return false;
+     }
+     
+     const isDeleted = await caches.delete(cacheName);
+     const stillExists = await checkCacheExists(cacheName);
+     
+     if (isDeleted && !stillExists) {
+       console.log(`Cache "${cacheName}" successfully deleted`);
+       // Notify clients that cache was deleted
+       const clients = await self.clients.matchAll();
+       clients.forEach(client => {
+         client.postMessage({
+           type: 'CACHE_DELETED',
+           cacheName,
+           success: true
+         });
+       });
+       return true;
+     } else {
+       console.error(`Failed to delete cache "${cacheName}"`);
+       return false;
+     }
+   } catch (error) {
+     console.error(`Error deleting cache "${cacheName}":`, error);
+     return false;
+   }
+ };
+ 
+ // Example usage:
+ // Listen for messages from clients
+ self.addEventListener('message', (event) => {
+   if (event.data && event.data.type === 'DELETE_CACHE') {
+     const { cacheName } = event.data;
+     deleteCache(cacheName).then(success => {
+       event.source?.postMessage({
+         type: 'CACHE_DELETED_RESULT',
+         cacheName,
+         success
+       });
+     });
+   }
+ });
  
```

---

To use this cache verification system from your application, create a function to communicate with the service worker:

---

```diff
- 
+ /**
+  * Utility functions for interacting with service worker cache
+  */
+ 
+ /**
+  * Requests the service worker to delete a specific cache
+  * @param cacheName The name of the cache to delete
+  * @returns Promise that resolves to a boolean indicating success
+  */
+ export const deleteCacheFromClient = (cacheName: string): Promise<boolean> => {
+   return new Promise((resolve) => {
+     // Check if service worker is active
+     if (!('serviceWorker' in navigator)) {
+       console.error('Service worker not supported');
+       resolve(false);
+       return;
+     }
+     
+     // Handle the response message from SW
+     const messageHandler = (event: MessageEvent) => {
+       if (
+         event.data && 
+         event.data.type === 'CACHE_DELETED_RESULT' && 
+         event.data.cacheName === cacheName
+       ) {
+         navigator.serviceWorker.removeEventListener('message', messageHandler);
+         resolve(event.data.success);
+       }
+     };
+     
+     // Listen for the response
+     navigator.serviceWorker.addEventListener('message', messageHandler);
+     
+     // Send delete request to all active service workers
+     navigator.serviceWorker.ready.then((registration) => {
+       if (registration.active) {
+         registration.active.postMessage({
+           type: 'DELETE_CACHE',
+           cacheName
+         });
+       } else {
+         console.error('No active service worker found');
+         navigator.serviceWorker.removeEventListener('message', messageHandler);
+         resolve(false);
+       }
+     }).catch(error => {
+       console.error('Error communicating with service worker:', error);
+       navigator.serviceWorker.removeEventListener('message', messageHandler);
+       resolve(false);
+     });
+     
+     // Set timeout in case service worker doesn't respond
+     setTimeout(() => {
+       navigator.serviceWorker.removeEventListener('message', messageHandler);
+       resolve(false);
+       console.error('Service worker did not respond in time');
+     }, 3000);
+   });
+ };
+ 
+ /**
+  * Get all available cache names
+  * @returns Promise that resolves to an array of cache names
+  */
+ export const listCaches = async (): Promise<string[]> => {
+   if ('caches' in window) {
+     return await caches.keys();
+   }
+   return [];
+ };
+ 
+ /**
+  * Listen for cache deletion notifications from service worker
+  * @param callback Function to call when a cache is deleted
+  */
+ export const listenForCacheDeletions = (
+   callback: (cacheName: string) => void
+ ): () => void => {
+   const handler = (event: MessageEvent) => {
+     if (event.data && event.data.type === 'CACHE_DELETED') {
+       callback(event.data.cacheName);
+     }
+   };
+   
+   navigator.serviceWorker.addEventListener('message', handler);
+   
+   // Return a function to remove the listener
+   return () => {
+     navigator.serviceWorker.removeEventListener('message', handler);
+   };
+ }; 
```

---

Now, let's create a simple component to demonstrate how to use these utilities:

---

```diff
- 
+ 'use client';
+ 
+ import React, { useState, useEffect } from 'react';
+ import { deleteCacheFromClient, listCaches, listenForCacheDeletions } from '../utils/cacheUtils';
+ 
+ const CacheManager = () => {
+   const [caches, setCaches] = useState<string[]>([]);
+   const [loading, setLoading] = useState(false);
+   const [message, setMessage] = useState('');
+   const [selectedCache, setSelectedCache] = useState('');
+ 
+   const loadCaches = async () => {
+     setLoading(true);
+     try {
+       const cacheList = await listCaches();
+       setCaches(cacheList);
+       if (cacheList.length > 0 && !selectedCache) {
+         setSelectedCache(cacheList[0]);
+       }
+     } catch (error) {
+       setMessage(`Error loading caches: ${error instanceof Error ? error.message : String(error)}`);
+     } finally {
+       setLoading(false);
+     }
+   };
+ 
+   const handleDeleteCache = async () => {
+     if (!selectedCache) {
+       setMessage('Please select a cache to delete');
+       return;
+     }
+     
+     setLoading(true);
+     setMessage('');
+     
+     try {
+       const success = await deleteCacheFromClient(selectedCache);
+       if (success) {
+         setMessage(`Successfully deleted cache: ${selectedCache}`);
+         // Remove the deleted cache from the list
+         setCaches(prev => prev.filter(cache => cache !== selectedCache));
+         setSelectedCache('');
+       } else {
+         setMessage(`Failed to delete cache: ${selectedCache}`);
+       }
+     } catch (error) {
+       setMessage(`Error deleting cache: ${error instanceof Error ? error.message : String(error)}`);
+     } finally {
+       setLoading(false);
+     }
+   };
+ 
+   useEffect(() => {
+     loadCaches();
+     
+     // Listen for cache deletion events from the service worker
+     const unsubscribe = listenForCacheDeletions((cacheName) => {
+       setMessage(`Cache ${cacheName} was deleted by the service worker`);
+       loadCaches();
+     });
+     
+     return () => {
+       unsubscribe();
+     };
+   }, []);
+ 
+   return (
+     <div className="p-4 bg-white rounded-lg shadow-md max-w-md mx-auto">
+       <h2 className="text-xl font-bold mb-4">Cache Manager</h2>
+       
+       <div className="mb-4">
+         <button 
+           onClick={loadCaches}
+           disabled={loading}
+           className="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:opacity-50 mr-2"
+         >
+           Refresh Cache List
+         </button>
+       </div>
+       
+       {caches.length > 0 ? (
+         <div className="mb-4">
+           <label className="block text-sm font-medium text-gray-700 mb-1">
+             Select Cache
+           </label>
+           <div className="flex gap-2">
+             <select
+               value={selectedCache}
+               onChange={(e) => setSelectedCache(e.target.value)}
+               className="w-full p-2 border border-gray-300 rounded-md"
+               disabled={loading}
+             >
+               <option value="">-- Select a cache --</option>
+               {caches.map((cache) => (
+                 <option key={cache} value={cache}>
+                   {cache}
+                 </option>
+               ))}
+             </select>
+             <button
+               onClick={handleDeleteCache}
+               disabled={loading || !selectedCache}
+               className="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600 disabled:opacity-50"
+             >
+               Delete
+             </button>
+           </div>
+         </div>
+       ) : (
+         <p className="text-gray-500 mb-4">No caches found</p>
+       )}
+       
+       {message && (
+         <div className={`p-3 rounded-md ${message.includes('Error') || message.includes('Failed') ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700'}`}>
+           {message}
+         </div>
+       )}
+       
+       {loading && (
+         <div className="flex justify-center items-center mt-4">
+           <div className="w-6 h-6 border-2 border-t-blue-500 rounded-full animate-spin"></div>
+           <span className="ml-2">Loading...</span>
+         </div>
+       )}
+     </div>
+   );
+ };
+ 
+ export default CacheManager; 
```

---

You now have a complete system for checking if caches are deleted successfully. To use it:

1. The service worker (app/sw.ts) has been updated with functions to:
   - Check if a cache exists
   - Delete a cache and verify deletion
   - Communicate deletion status back to the client

2. A utility module (app/utils/cacheUtils.ts) provides functions to:
   - Request cache deletion from the client
   - List available caches
   - Listen for cache deletion events

3. A React component (app/components/CacheManager.tsx) demonstrates how to:
   - List all available caches
   - Delete a selected cache
   - Verify deletion success
   - Show appropriate loading states and feedback

You can import and use the CacheManager component in any page where you need to manage caches, or use the utility functions directly for programmatic cache management.

---

_**User**_

The offline page is available but I need to redirect to it when the user is offline

---

_**Assistant**_



---

I'll update your service worker to properly redirect to the offline page when a user is offline for any document request, not just the homepage:

---

```diff
    // disableDevLogs: true,
    importScripts: ["/custom-sw.js"],
-   // fallbacks: {
-   //   entries: [
-   //     {
-   //       url: "/offline",
-   //       matcher({ request }) {
-   //         return request.destination === "document";
-   //       },
-   //     },
-   //   ],
-   // },
- });
+   fallbacks: {
+     entries: [
+       {
+         url: "/offline",
+         matcher({ request }) {
+           return request.destination === "document";
+         },
+       },
+     ],
+   },
+ });
+ 
+ // Handle navigation requests to any page
+ serwist.registerCapture(
+   // Match all navigation requests (HTML documents)
+   ({ request }) => request.mode === "navigate",
+   new NetworkOnly({
+     plugins: [
+       new PrecacheFallbackPlugin({
+         fallbackUrls: ["/offline"],
+         serwist,
+       }),
+     ],
+   })
+ );
  
+ // The original root path handler
  serwist.registerCapture(
    /^\/$/,
```

```diff
  
  serwist.addEventListeners();
+ 
+ // Check network status and handle offline state
+ self.addEventListener('fetch', (event) => {
+   // Only handle navigation requests for HTML documents
+   if (event.request.mode === 'navigate') {
+     event.respondWith(
+       fetch(event.request).catch(() => {
+         // If fetch fails (offline), redirect to the offline page
+         return caches.match('/offline').then((response) => {
+           return response || new Response('You are offline', {
+             status: 503,
+             statusText: 'Service Unavailable',
+             headers: new Headers({
+               'Content-Type': 'text/html'
+             })
+           });
+         });
+       })
+     );
+   }
+ });
  
```

---

Now let's make sure the offline page is properly created:

---

<details>
            <summary>Searched codebase "offline" • **1** results</summary>
        
| File |
|------|
| `undefined` |

</details>

---

Read file: app/offline/page.tsx

---

Let's check if we need to make any additional changes to the offline page:

---

```diff
  export default function OfflinePage() {
    return (
-     <Card className="w-full  max-w-md flex items-center justify-center min-h-[50vh]">
-       <CardHeader className="text-center">
-         <WifiOff className="mx-auto h-12 w-12 text-muted-foreground mb-2" />
-         <CardTitle className="text-2xl">You're Offline</CardTitle>
-       </CardHeader>
-       <CardContent className="space-y-4 mx-auto text-center">
-         <p>
-           You appear to be offline. Don't worry - you can still access cached
-           content and use many features of the app.
-         </p>
-         <Button asChild>
-           <Link href="/">Go to Homepage</Link>
-         </Button>
-       </CardContent>
-     </Card>
+     <div className="container flex items-center justify-center min-h-screen p-4">
+       <Card className="w-full max-w-md">
+         <CardHeader className="text-center">
+           <WifiOff className="mx-auto h-12 w-12 text-muted-foreground mb-2" />
+           <CardTitle className="text-2xl">You're Offline</CardTitle>
+         </CardHeader>
+         <CardContent className="space-y-4">
+           <p className="text-center text-muted-foreground">
+             You appear to be offline. Don't worry - you can still access cached
+             content and use many features of the app.
+           </p>
+           <div className="flex flex-col sm:flex-row gap-3 justify-center">
+             <Button asChild variant="default">
+               <Link href="/">Go to Homepage</Link>
+             </Button>
+             <Button 
+               variant="outline" 
+               onClick={() => {
+                 window.location.reload();
+               }}
+             >
+               Retry Connection
+             </Button>
+           </div>
+         </CardContent>
+       </Card>
+     </div>
    );
  }
```

---

Now, let's create a simple network status checker component that will help monitor online/offline status and provide a user-friendly notification:

---

```diff
- 
+ 'use client';
+ 
+ import { useEffect, useState } from 'react';
+ import { WifiOff, Wifi } from 'lucide-react';
+ 
+ export const NetworkStatus = () => {
+   const [isOnline, setIsOnline] = useState(true);
+   const [showNotification, setShowNotification] = useState(false);
+   
+   useEffect(() => {
+     // Initialize with the current network status
+     setIsOnline(navigator.onLine);
+     
+     // Event handlers for online/offline events
+     const handleOnline = () => {
+       setIsOnline(true);
+       // Show notification when coming back online
+       setShowNotification(true);
+       // Hide notification after 3 seconds
+       setTimeout(() => setShowNotification(false), 3000);
+     };
+     
+     const handleOffline = () => {
+       setIsOnline(false);
+       // Show notification when going offline
+       setShowNotification(true);
+     };
+     
+     // Add event listeners
+     window.addEventListener('online', handleOnline);
+     window.addEventListener('offline', handleOffline);
+     
+     // Clean up event listeners
+     return () => {
+       window.removeEventListener('online', handleOnline);
+       window.removeEventListener('offline', handleOffline);
+     };
+   }, []);
+   
+   // If online and not showing notification, don't render anything
+   if (isOnline && !showNotification) return null;
+   
+   return (
+     <div 
+       className={`fixed bottom-4 right-4 z-50 flex items-center space-x-2 rounded-lg shadow-lg px-4 py-3 transition-all duration-300 ${
+         isOnline 
+           ? 'bg-green-100 text-green-800' 
+           : 'bg-red-100 text-red-800'
+       }`}
+     >
+       {isOnline ? (
+         <>
+           <Wifi className="h-5 w-5" />
+           <span>You're back online!</span>
+         </>
+       ) : (
+         <>
+           <WifiOff className="h-5 w-5" />
+           <span>You're offline. Some features may be unavailable.</span>
+         </>
+       )}
+     </div>
+   );
+ };
+ 
+ export default NetworkStatus; 
```

---

Let's add this NetworkStatus component to the layout so it's available throughout the application:

---

<details>
            <summary>Searched codebase "layout.tsx" • **4** results</summary>
        
| File |
|------|
| `undefined` |
| `undefined` |
| `undefined` |
| `undefined` |

</details>

---

Read file: app/layout.tsx

---

Read file: app/layout-wrapper.tsx

---

Let's update the layout-wrapper to include our NetworkStatus component:

---

```diff
  import { PWANavigation } from "@/components/PWANavigation";
  import Link from "next/link";
+ import dynamic from 'next/dynamic';
+ 
+ // Import NetworkStatus component with dynamic loading to prevent SSR issues
+ const NetworkStatus = dynamic(() => import('@/components/NetworkStatus'), { 
+   ssr: false 
+ });
  
  interface LayoutWrapperProps {
```

```diff
          </p>
        </footer>
+       
+       {/* Network status indicator */}
+       <NetworkStatus />
      </div>
    );
```

---

Now let's create a utility that can be used to programmatically check if a user is online and redirect to the offline page if needed:

---

```diff
- 
+ 'use client';
+ 
+ /**
+  * Checks if the user is currently online
+  * @returns Boolean indicating if the user has network connectivity
+  */
+ export const isOnline = (): boolean => {
+   if (typeof navigator !== 'undefined') {
+     return navigator.onLine;
+   }
+   return true; // Default to true on server
+ };
+ 
+ /**
+  * Redirects to the offline page if the user is offline
+  * @param router Next.js router instance
+  * @returns Boolean indicating if redirect happened
+  */
+ export const redirectIfOffline = (router: any): boolean => {
+   if (!isOnline()) {
+     router.push('/offline');
+     return true;
+   }
+   return false;
+ };
+ 
+ /**
+  * Subscribes to network status changes and calls the appropriate callback
+  * @param onOnline Function to call when network comes online
+  * @param onOffline Function to call when network goes offline
+  * @returns Function to unsubscribe the event listeners
+  */
+ export const subscribeToNetworkChanges = (
+   onOnline: () => void,
+   onOffline: () => void
+ ): () => void => {
+   if (typeof window === 'undefined') return () => {};
+   
+   window.addEventListener('online', onOnline);
+   window.addEventListener('offline', onOffline);
+   
+   return () => {
+     window.removeEventListener('online', onOnline);
+     window.removeEventListener('offline', onOffline);
+   };
+ };
+ 
+ /**
+  * Attempts to make a network request to check connectivity
+  * This is more reliable than just navigator.onLine
+  * @returns Promise resolving to boolean indicating connectivity
+  */
+ export const checkRealConnectivity = async (): Promise<boolean> => {
+   try {
+     // Fetch a tiny resource with cache busting
+     const response = await fetch(
+       `/api/ping?_=${Date.now()}`,
+       { method: 'HEAD', cache: 'no-store', mode: 'no-cors' }
+     );
+     return response.ok;
+   } catch (error) {
+     return false; // Network error means offline
+   }
+ }; 
```

---

Now, let's create a simple utility API route for the ping endpoint we referenced above:

---

```diff
- 
+ import { NextResponse } from 'next/server';
+ 
+ /**
+  * Simple endpoint to check if the server is reachable
+  * Used to verify real network connectivity beyond navigator.onLine
+  */
+ export async function GET() {
+   return NextResponse.json(
+     { online: true, timestamp: Date.now() },
+     { status: 200, headers: { 'Cache-Control': 'no-store, max-age=0' } }
+   );
+ }
+ 
+ export async function HEAD() {
+   return new NextResponse(null, {
+     status: 200,
+     headers: { 'Cache-Control': 'no-store, max-age=0' }
+   });
+ } 
```

---

Now that we have all the necessary components in place, let's create an example usage in a component that demonstrates how to handle offline states and redirects:

---

Cancelled

---

